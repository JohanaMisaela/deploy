{"version":3,"file":"static/js/346.3ccb47c7.js","mappings":"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","sources":["plugins/transcription/Transcriber.js","plugins/transcription/TranscriptionButton.jsx"],"sourcesContent":["import RecordRTC, { StereoAudioRecorder } from \"recordrtc\";\nimport {\n  selectIsLocalAudioEnabled,\n  selectLocalPeerName,\n} from \"@100mslive/react-sdk\";\n\nexport class Transcriber {\n  constructor(\n    hmsStore,\n    setTranscriptAndSpeakingPeer,\n    setIsTranscriptionEnabled\n  ) {\n    this.hmsStore = hmsStore;\n    this.enabled = false;\n    this.audioSocket = null; // this is the socket that will be used to send audio to the STT server\n    this.setTranscriptAndSpeakingPeer = setTranscriptAndSpeakingPeer;\n    this.setIsTranscriptionEnabled = setIsTranscriptionEnabled;\n    this.sttTuningConfig = {\n      timeSlice: 250,\n      desiredSampRate: 8000,\n      numberOfAudioChannels: 1,\n      bufferSize: 256,\n    };\n    this.resetTextTimer = null; // used to reset the transcript after some time, if no new update comes\n    this.localPeerName = hmsStore.getState(selectLocalPeerName);\n    this.observingLocalPeerTrack = false;\n    this.trackIdBeingObserved = null;\n    this.recordRTCInstance = null;\n    this.unsubscribes = [];\n  }\n\n  async toggleTranscriptionState() {\n    await this.enableTranscription(!this.enabled);\n  }\n\n  async enableTranscription(enable) {\n    if (enable === this.enabled) {\n      return;\n    }\n    console.log(\"transcription enabled\", enable);\n    if (enable) {\n      this.enabled = true;\n      await this.setIsTranscriptionEnabled(true);\n      await this.listen();\n    } else {\n      this.enabled = false;\n      await this.setIsTranscriptionEnabled(false);\n      this.cleanup();\n    }\n  }\n\n  setTranscriptAndPeerWithExpiry(transcript, peerName) {\n    if (!transcript) {\n      return;\n    }\n    this.setTranscriptAndSpeakingPeer(transcript, `[${peerName}]`);\n    // reset after some time if no new update comes\n    clearTimeout(this.resetTextTimer);\n    this.resetTextTimer = setTimeout(() => {\n      this.resetTranscriptAndPeer();\n    }, 5000);\n  }\n\n  resetTranscriptAndPeer() {\n    this.setTranscriptAndSpeakingPeer(\"\", \"\");\n    clearTimeout(this.resetTextTimer);\n  }\n\n  async listen(retryCount = 0) {\n    if (retryCount > 5) {\n      console.error(\"transcription\", \"Max retry count reached!!\", retryCount);\n      this.cleanup();\n      return;\n    }\n    try {\n      let url = process.env.REACT_APP_DYNAMIC_STT_TOKEN_GENERATION_ENDPOINT;\n      let res = await fetch(url);\n      let body = await res.json();\n      const authToken = body.token;\n\n      if (authToken) {\n        this.audioSocket = await new WebSocket(\n          `wss://api.assemblyai.com/v2/realtime/ws?sample_rate=${this.sttTuningConfig.desiredSampRate}&token=${authToken}`\n        );\n        this.resetTranscriptAndPeer();\n        this.audioSocket.onmessage = message => {\n          try {\n            const res = JSON.parse(message.data);\n            if (res.text && this.enabled) {\n              //Limiting the transcript size based on it's charecter length.\n              let messageText =\n                res.text.length >= 80\n                  ? res.text\n                      .split(\" \")\n                      .slice(Math.max(res.text.split(\" \").length - 10, 1))\n                      .join(\" \")\n                  : res.text;\n              if (messageText) {\n                this.setTranscriptAndPeerWithExpiry(\n                  messageText,\n                  this.localPeerName\n                );\n              }\n            }\n          } catch (err) {\n            console.error(\"transcription\", err);\n          }\n        };\n\n        this.audioSocket.onerror = event => {\n          console.error(\"transcription\", event);\n          this.audioSocket.close();\n        };\n\n        this.audioSocket.onclose = event => {\n          try {\n            console.log(event);\n            this.audioSocket = null;\n            if (this.enabled && event.code !== 4001) {\n              this.listen(retryCount++);\n            }\n          } catch (err) {\n            console.error(\"transcription\", err);\n          }\n        };\n\n        this.audioSocket.onopen = () => {\n          this.observeLocalPeerTrack();\n        };\n      } else {\n        console.error(\"Unable to fetch dynamic token!!\");\n      }\n    } catch (err) {\n      console.error(\"transcription\", err);\n    }\n  }\n\n  async observeLocalPeerTrack() {\n    try {\n      if (this.observingLocalPeerTrack) {\n        return;\n      }\n      this.observingLocalPeerTrack = true;\n      console.log(\"transcription - observing local peer track\");\n      let unsub = this.hmsStore.subscribe(\n        this.getAndObserveStream,\n        selectIsLocalAudioEnabled\n      );\n      this.unsubscribes.push(unsub);\n      this.getAndObserveStream(); // call it once to start observing initially\n    } catch (err) {\n      console.error(\"transcription - observing local peer track\", err);\n    }\n  }\n\n  /**\n   * This method is used to get the local peer's stream and observe it for changes.\n   * @returns {Promise<void>}\n   */\n  getAndObserveStream = async () => {\n    // a hacky way to get the local peer's stream till we have a better way\n    const localPeer = window.__hms.sdk.getLocalPeer();\n    const mediaTrack = localPeer.audioTrack.nativeTrack;\n    if (!mediaTrack || mediaTrack.id === this.trackIdBeingObserved) {\n      return;\n    }\n    this.trackIdBeingObserved = mediaTrack.id;\n    console.log(\"transcription - observing local peer track\", mediaTrack.id);\n    try {\n      if (this.recordRTCInstance) {\n        console.log(\"transcription - destroying earlier instance\");\n        this.recordRTCInstance.destroy();\n      }\n      this.recordRTCInstance = null;\n    } catch (err) {\n      console.error(\"transcription - in destroying earlier instance\", err);\n    }\n    const stream = new MediaStream([mediaTrack]);\n    await this.observeStream(stream);\n  };\n\n  async observeStream(stream) {\n    this.recordRTCInstance = new RecordRTC(stream, {\n      ...this.sttTuningConfig,\n      type: \"audio\",\n      mimeType: \"audio/webm;codecs=pcm\",\n      recorderType: StereoAudioRecorder,\n      ondataavailable: blob => {\n        const reader = new FileReader();\n        reader.onload = () => {\n          const base64data = reader.result;\n          if (\n            this.audioSocket &&\n            this.enabled &&\n            this.audioSocket.readyState &&\n            this.audioSocket.readyState === 1\n          ) {\n            try {\n              this.audioSocket.send(\n                JSON.stringify({ audio_data: base64data.split(\"base64,\")[1] })\n              );\n            } catch (err) {\n              console.error(\"transcription\", err);\n            }\n          }\n        };\n        reader.readAsDataURL(blob);\n      },\n    });\n    this.recordRTCInstance.startRecording();\n  }\n\n  cleanup() {\n    console.log(\"transcription - cleanup\");\n    if (this.audioSocket) {\n      try {\n        this.audioSocket.close();\n        this.audioSocket = null;\n      } catch (err) {\n        console.error(\"transcription cleanup - couldn't close socket\", err);\n      }\n    }\n    if (this.recordRTCInstance) {\n      try {\n        this.recordRTCInstance.destroy();\n        this.recordRTCInstance = null;\n      } catch (err) {\n        console.error(\"transcription cleanup - couldn't stop recording\", err);\n      }\n    }\n    for (const unsub of this.unsubscribes) {\n      unsub();\n    }\n    this.resetTranscriptAndPeer();\n  }\n}\n","import { useCallback, useEffect, useRef } from \"react\";\nimport {\n  selectIsAllowedToPublish,\n  selectSessionStore,\n  useHMSActions,\n  useHMSStore,\n  useHMSVanillaStore,\n} from \"@100mslive/react-sdk\";\nimport { ClosedCaptionIcon } from \"@100mslive/react-icons\";\nimport { Box, IconButton, Text, Tooltip } from \"@100mslive/react-ui\";\nimport { Transcriber } from \"./Transcriber\";\nimport { SESSION_STORE_KEY } from \"../../common/constants\";\n\nexport function TranscriptionButton() {\n  const transcriptionState = useHMSStore(\n    selectSessionStore(SESSION_STORE_KEY.TRANSCRIPTION_STATE)\n  );\n  const rawStore = useHMSVanillaStore();\n  const isTranscriptionEnabled = !!transcriptionState?.enabled;\n  let transcript = \"\",\n    speakingPeer = \"\";\n  if (isTranscriptionEnabled) {\n    transcript = transcriptionState.transcript || \"\";\n    speakingPeer = transcriptionState.speakingPeer || \"\";\n  }\n\n  const transcriber = useRef(null);\n  const hmsActions = useHMSActions();\n  const isAllowedToPublish = useHMSStore(selectIsAllowedToPublish);\n\n  useEffect(() => {\n    hmsActions.sessionStore.observe(SESSION_STORE_KEY.TRANSCRIPTION_STATE);\n  }, [hmsActions]);\n\n  useEffect(() => {\n    if (!transcriber.current) {\n      transcriber.current = new Transcriber(\n        rawStore,\n        async (transcript, peerName) => {\n          await hmsActions.sessionStore.set(\n            SESSION_STORE_KEY.TRANSCRIPTION_STATE,\n            {\n              enabled: true,\n              transcript,\n              speakingPeer: peerName,\n            }\n          );\n        },\n        async isEnabled => {\n          await hmsActions.sessionStore.set(\n            SESSION_STORE_KEY.TRANSCRIPTION_STATE,\n            {\n              enabled: isEnabled,\n            }\n          );\n        }\n      );\n    }\n    return () => {\n      if (transcriber.current) {\n        transcriber.current.cleanup();\n      }\n    };\n  }, [hmsActions, rawStore]);\n\n  useEffect(() => {\n    // remote enabled transcript\n    if (isTranscriptionEnabled) {\n      transcriber.current.enableTranscription(true);\n    }\n  }, [isTranscriptionEnabled]);\n\n  const toggleTranscriptionState = useCallback(() => {\n    transcriber.current.toggleTranscriptionState();\n  }, []);\n\n  return (\n    <>\n      <Box\n        css={{\n          textAlign: \"left\",\n          fontWeight: \"$medium\",\n          bottom: \"120px\",\n          position: \"fixed\",\n          width: \"100%\",\n          fontSize: \"$20px\",\n          zIndex: \"1000000\",\n          color: \"white\",\n          textShadow: \"0px 0px 6px #000\",\n          whiteSpace: \"pre-line\",\n          paddingLeft: \"40px\",\n        }}\n      />\n      <Box\n        css={{\n          textAlign: \"center\",\n          fontWeight: \"$medium\",\n          bottom: \"90px\",\n          position: \"fixed\",\n          width: \"100%\",\n          fontSize: \"$20px\",\n          zIndex: \"1000000\",\n          color: \"white\",\n          textShadow: \"0px 0px 6px #000\",\n          whiteSpace: \"pre-line\",\n        }}\n      >\n        <Text\n          css={{\n            color: \"white\",\n            textShadow: \"0px 0px 6px #000\",\n          }}\n        >\n          {transcript}\n        </Text>\n        <Text\n          css={{\n            color: \"#c0bbbb\",\n            textShadow: \"0px 0px 6px #000\",\n            textTransform: \"capitalize\",\n          }}\n        >\n          {speakingPeer}\n        </Text>\n      </Box>\n      {isAllowedToPublish.audio && (\n        <Tooltip\n          title={`Turn ${!isTranscriptionEnabled ? \"on\" : \"off\"} transcription`}\n        >\n          <IconButton\n            active={!isTranscriptionEnabled}\n            onClick={toggleTranscriptionState}\n            data-testid=\"transcription_btn\"\n          >\n            <ClosedCaptionIcon />\n          </IconButton>\n        </Tooltip>\n      )}\n    </>\n  );\n}\n"],"names":["Transcriber","hmsStore","setTranscriptAndSpeakingPeer","setIsTranscriptionEnabled","mediaTrack","err","stream","enable","transcript","peerName","retryCount","url","authToken","message","res","messageText","event","unsub","blob","reader","base64data","TranscriptionButton","transcriptionState","rawStore","isTranscriptionEnabled","speakingPeer","transcriber","hmsActions","isAllowedToPublish","isEnabled","toggleTranscriptionState","Box","Text","Tooltip","IconButton","ClosedCaptionIcon"],"sourceRoot":""}